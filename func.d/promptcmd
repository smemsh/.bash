#
# called by bash via $PROMPT_COMMAND after a command completes
#
# - expects return value of previous command as sole argument
# - logged timestamps will reflect command completion, not start
#
##############################################################################

prompt_command ()
{
	# get path settings, etc
	#
	[[ "$AKRC" ]] || return 5
	test -e $AKRC || return 10
	test -r $AKRC || return 13
	source $AKRC  || return 15

	local num time_t command file

	local now_time_t="$(date +%s)"
	local now_timefmt="$(date -d @$now_time_t +$HISTTIMEFORMAT)"

	# get dynamic akassoc vars
	#
	AKLOGVALS=(
		$AKASSOC
		$now_timefmt
		$AKTTY_TYPE
		$AKTTY_NUM
		$SHLVL
		$1 # passed by shell in `$PROMPT_COMMAND': previous command result code
	)

	# read in the last command from bash's history
	# note: must use raw read (with '-r') or '\n' etc will log as 'n'
	#
	read -r num time_t command <<< "$(HISTTIMEFORMAT="%s "; history 1)"

	# gather command and metadata that we'll write to log file
	#
	AKLOGLAST="$AKLOGLINE"
	AKLOGLINE="${AKLOGVALS[*]} $command"

	# check that we haven't seen it already; this happens on empty command
	# TODO: why the check against AKSTART? when can it happen?
	#
	[[ $AKLOGLAST == $AKLOGLINE ]] && return
	((time_t < AKSTART)) && return

	# now write them to the log files we maintain for akassoc
	#
	echo "$AKLOGLINE" >> $AKLOG_CMDS		# logfile1
	echo "$AKLOGLINE" >> $AKLOG_MOST		# logfile2
	for file in $AKLOG_FULL $AKLOG_BASH; do		# logfile3, logfile4
		printf "#%u\n%s\n" \
			"$time_t" \
			"$command" \
		>> $file
	done
}
