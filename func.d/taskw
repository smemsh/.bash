#
# taskwarrior
#

# work around always defaulting to 80 columns when piping
# note: ${COLUMNS:-80} not needed, blank value is default (which is 80)
# todo: implement env var expansion in taskwarrior
# also: #991
#
task ()
{
	for arg; do if [[ $arg == '--' ]]; then break
	elif [[ $arg == '--version' ]]
	then `type -P task` --version; return; fi; done

	`type -P task` rc.defaultwidth=$COLUMNS "$@"
}

taskl ()
{
	local taskid=$1; shift
	task $(taskid $taskid) "$@"
}

taskcur ()
{
	local tasknow=($(tasknow))
	local status=${tasknow[1]}
	local name=${tasknow[0]}

	if [[ $status != 'started' ]]; then
		echo "current task $name not engaged, aborting" >&2
		false; return; fi

	task $(taskid $name) "$@"
}

# for taskadd
#
taskaddl () { TASKADD="$*"; } # additional args (such as tags)
taskprj () { TASKPRJ="$@"; } # default project

# look in more fields that have text, default is only description
taskgrepu () { taskgrep_report=export taskgrep "$@" | jq -r '.[].uuid'; }
taskgrepx () { taskgrep_report=export taskgrep "$@" | jq -r .; }
taskgrepp () { taskgrep_report=all taskgrep "$@"; }
taskgrep  ()
{
	local pattern
	local -a patexprs rstpaths noteuuids

	for pattern; do patexprs+=(-e "$pattern"); done
	rstpaths=($(grep -Els "${patexprs[@]}" ~/.task/notes/*.rst))
	if ((${#rstpaths[@]}))
	then noteuuids=($(basename -s .rst ${rstpaths[@]}))
	else noteuuids=()
	fi

	task $(taskids -za -- "$@" ${noteuuids[@]}) ${taskgrep_report:-next}
}

tasknote ()
{
	(rcfile=~/.taskopenrc; if test -e $rcfile; then
		source $rcfile
		results=($(taskgrepu "$@"))
		nresults=${#results[@]}
		for ((i = 0; i < nresults; i++)); do
			uuid=${results[i]}
			file=${NOTES_FOLDER:?}/$uuid.rst
			if test -r $file; then
				((nresults > 1)) && printf "==> %s\n" $uuid
				cat $file; fi; done; fi)
}

taskgc ()
{
	(($(task +DELETED _unique uuid | wc -l))) &&
		task rc.bulk=0 +DELETED purge
	task rc.gc=on rc.verbose=nothing // list >/dev/null
}

### timewarrior

timedo ()
{
	(($# > 1)) && { echo "zero or one arg" >&2; false; return; }
	(($# == 0)) && set -- todo
	timew start time/${1:?}
}

taskstat ()
{
	local all
	[[ $1 == '-a' || $1 == '--all' ]] && { all=:all; shift; }
	timew summary "$@" :ids $all
}

timeredo ()
{
	local n i ival
	local -a ivals olds

	while [[ $1 =~ ^@ ]]; do ivals+=($1); shift; done
	n=${#ivals[@]}
	if ((n == 0 || $# == 0)); then
		echo "$FUNCNAME: overwrite tags for given intervals" >&2
		echo " usage: $FUNCNAME [@interval]... [tag]..." >&2
		false
		return
	fi

	for ((i = 0; i < n; i++)); do
		ival=${ivals[i]#@}
		if (($(timew get dom.tracked.$ival.tag.count))); then
			olds=($(
				timew get dom.tracked.$ival.json |
				jq -r '.tags[]'
			))
			if ! timew untag @$ival "${olds[@]}"
			then echo "untag failed" >&2; false; return; fi
		fi
		if ! timew tag @$ival "$@"
		then echo "tag failed" >&2; false; return; fi
	done
}

# todo: do this in totals.py instead, making a new report.py,
# adding tag counts and hierarchy counts
#
taskreport ()
{
	timew totals ${1:-:week} \
	| grep / \
	| awk '{print $2, $1}' \
	| grep -v /$ \
	| sort -nrk 1,1 \
	| awk '
	BEGIN { timeformat = "%3u:%02u:%02u" }
	{
		split($1, times, ":")
		fql = $2
		h = times[1]; m = times[2]; s = times[3]
		hours += h; minutes += m; seconds += s
		printf(timeformat " %s\n", h, m, s, fql)
	}
	END {
		minutes = minutes + (int(seconds / 60))
		seconds = seconds % 60
		hours = hours + int(minutes / 60)
		minutes = minutes % 60
		printf(timeformat " <-- TOTAL\n", hours, minutes, seconds)
	}'
}

taskdel ()
{
	taskn "${@:?}" delete &&
	taskn "$@" purge &&
	taskgc &&
	taskgc # TODO: why needed twice? try again after 2.6.2
}
